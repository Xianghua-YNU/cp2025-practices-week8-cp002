# 实验五：不同形式级数求和的数值稳定性比较实验报告

## 1. 实验目的
1. 实现并比较三种不同形式的调和级数求方法和
2. 观察和量化不同计算形式在数值精度上的差异
3. 理解灾难性抵消对数值计算的影响
4. 分析不同求和方法的误差增长趋势

## 2. 实验原理
### 2.1 三种级数形式
1. 交错级数形式：

$$ S_N^{(1)} = \sum_{n=1}^{2N} (-1)^n \frac{n}{n+1} $$

2. 两项求和相减形式：

$$ S_N^{(2)} = -\sum_{n=1}^{N} \frac{2n-1}{2n} + \sum_{n=1}^{N} \frac{2n}{2n+1} $$

3. 直接求和形式：

$$ S_N^{(3)} = \sum_{n=1}^{N} \frac{1}{2n(2n+1)} $$

### 2.2 相对误差计算
以 $S_N^{(3)}$ 为参考值，计算其他两种方法的相对误差：

$$ \text{Err}_1 = \left| \frac{S_N^{(1)} - S_N^{(3)}}{S_N^{(3)}} \right| $$
$$ \text{Err}_2 = \left| \frac{S_N^{(2)} - S_N^{(3)}}{S_N^{(3)}} \right| $$

## 3. 实验方法
### 3.1 代码实现
1. `sum_S1(N)` 函数实现：
   - 使用 result = 0.0 初始化一个浮点数变量，用于存储累加结果。
   使用 for 循环遍历 n 从 1 到 2N（包含 2N）：
   符号项：(-1)**n 实现交替的正负号（n 为奇数时负，偶数时正）。
   分数项：n / (n + 1) 计算每一项的值。
   累加：将每一项的值加到 result 中。
   循环结束后，返回 result 作为部分和。

2. `sum_S2(N)` 函数实现：
   - sum1 用于存储第一个求和部分（奇数项负值）
   sum2 用于存储第二个求和部分（偶数项正值）
   使用同一个循环同时计算 sum1 和 sum2，避免重复计算：
   奇数项（负贡献）：(2n - 1) / (2n)
   偶数项（正贡献）：(2n) / (2n + 1)
   最终结果为 -sum1 + sum2，对应原交错级数的重组形式。

3. `sum_S3(N)` 函数实现：
   -使用 result = 0.0 初始化累加器。
   遍历 n 从 1 到 N（含 N）：
   直接计算每一项的值：1.0 / (2*n * (2*n + 1))。
   累加到 result 中。
   返回 result 作为部分和。

### 3.2 数据收集与处理
1. N值选取：使用 `np.logspace(0, 4, 50)` 在对数尺度上取点
2. 计算三种方法的求和结果
3. 计算相对误差
4. 绘制双对数误差图

## 4. 实验结果
### 4.1 数据记录
| N | $S_N^{(1)}$ | $S_N^{(2)}$ | $S_N^{(3)}$ | $\text{Err}_1$ | $\text{Err}_2$ |
|---|-------------|-------------|-------------|----------------|----------------|
| 10 |            |             |             |                |                |
| 100 |           |             |             |                |                |
| 1000 |          |             |             |                |                |
| 10000 |         |             |             |                |                |

### 4.2 误差分析图
（在此插入相对误差随N变化的双对数图）

## 5. 分析与讨论
### 5.1 误差大小比较
1. 不同方法的误差比较：
   - （分析哪种方法误差更![313a2f29-6f1f-4c53-aead-ddc939d7fb0b](https://github.com/user-attachments/assets/0807b622-5b04-42c8-a7ed-a969f4f1f896)
小）
   - （分析误差增长速度）![image](https://github.com/user-attachments/assets/1d4c36de-faca-4926-a683-2fa253da93da)


2. 灾难性抵消分析：
   - （分析 $S_N^{(2)}$中两个内部和的变化）
   - ![image](https://github.com/user-attachments/assets/05e2fbc9-fff1-407f-81e6-149c10d99276)

   - （解释为什么会发生灾难性抵消）
   - 主导项抵消：Sum1 和 Sum2 的线性增长项完全抵消，仅剩对数项和高阶小项：

### 5.2 误差增长行为
1. 误差与N的幂律关系：
   - （分析双对数图的线性部分）
  ![image](https://github.com/user-attachments/assets/be01f5bc-9422-4677-b20e-ea6c669d4c4a)

   
   - （估算幂指数p）
   ![image](https://github.com/user-attachments/assets/a849dc74-1cc1-493f-b95c-f7e49ef323d2)

2. 误差增长原因：
   - （从数值计算角度解释误差增长的原因）
   - 舍入误差：问题本质：计算机使用有限位数（如双精度浮点数的52位尾数）表示实数，每次运算会引入微小误差。
   - 截断误差：问题本质：有限项求和忽略无穷级数的剩余项，导致理论误差。
   
## 6. 结论
1. 不同计算形式的数值稳定性比较
S3稳定性最高：其通项为1/(2n(2n+1))，均为正数相加，无抵消误差，且项数仅为N（而非2N），累积舍入误差更小。
S2中等稳定：虽然分正负部分求和，但每部分均为同号项相加，最后仅需一次减法，抵消影响可控。
S1稳定性最差：交错项的逐项抵消导致有效数字不断丢失。

2. 灾难性抵消对计算精度的影响
S1的抵消：
(-1)^n * n/(n+1)在求和时，相邻项的大数相减（如100/101 - 99/100 ≈ 0.0001）导致有效数字急剧丢失。
S2的抵消：
虽最终需计算-sum1 + sum2，但sum1和sum2各自独立求和，抵消仅发生在最后一步，影响较小。
当两个相近的浮点数相减时，高位有效数字会抵消，低位舍入误差被放大。

3. 数学等价与数值计算的关系
三种形式均严格等价于同一级数：
S = ∑_{n=1}^∞ [(-1)^n n/(n+1)] = ∑_{n=1}^∞ [1/(2n(2n+1))] ≈ 0.193147
数学等价 ≠ 计算等价：
浮点数的有限精度（如IEEE 754双精度约16位有效数字）使得不同形式的计算路径产生不同误差。

## 7. 思考题
1. 为什么数学上等价的表达式在数值计算中会有如此大的差异？
浮点数的有限精度与舍入误差、 灾难性抵消、计算顺序与累积误差。
运算顺序的影响：
浮点数加法不满足严格结合律（由于舍入误差），不同的求和顺序会导致不同结果。

2. 在实际编程中，如何避免类似的数值不稳定性？
优先选择数值稳定的数学形式，通过数学变形消除抵消或减少敏感操作（如相减、大数加小数）。
使用补偿求和算法，必须处理交替级数或大量累加时。
调整计算顺序，对正负项分别求和，最后合并。

5. 除了本实验中的三种形式，你能想到其他数值更稳定的计算方式吗？
部分分式分解：
![13adfde88f16964d56ca4cd805364786](https://github.com/user-attachments/assets/1ce5b26c-a134-45ec-a486-df43fbeb7d96)


## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
