# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

| N | $S^{(up)}$ | $S^{(down)}$ | 相对差异 δ |
|---|------------|--------------|------------|
| 10 |  2.92896825         |  2.92896825            |   0.00000000e+00         |
| 100 |     5.18737752     |      5.18737752        |  1.71219160e-16          |
| 1000 |      7.48547086   |      7.48547086        |   3.55960942e-16         |
| 10000 |     9.78760604   |     9.78760604         |  3.81129905e-15          |

### 4.2 误差分析图
（在此插入相对差异δ随N变化的双对数图）
<img width="736" alt="a5a9c3cae062a69f4bec4160a5212af" src="https://github.com/user-attachments/assets/7f8f0586-ba4e-4e30-b7b2-5e51495d2cd3" />

## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   从图表来看，相对差异随N的变化呈现出波动的趋势。在N较小时（从10^{1}开始），相对差异有较大的起伏，随着N逐渐增大到10^{2} 、10^{3} ，相对差异依然波动明显，没有呈现出单纯的递增或递减趋势。在N接近10^{4} 时，相对差异整体处于较高水平且仍在波动。这表明相对差异与N之间并非简单的单调关系，N的变化对相对差异的影响较为复杂，可能受到多种因素综合作用 。


2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）:在数值计算中，当进行加法运算时，若从大到小求和（假设S^{(down)}是从大到小求和的结果 ），较小的数在加入较大数的和时，由于浮点数的精度限制，对总和的影响相对较小，舍入误差累积相对较少。而如果从小到大求和，随着求和过程推进，舍入误差会不断累积，使得最终结果偏离真实值更多，所以S^{(down)} 更精确 。

   - （结合浮点数表示方式解释）:浮点数在计算机中采用有限的二进制位数来表示。例如单精度浮点数用32位表示，双精度用64位。当进行加法运算时，若两个数相差过大，较小数的有效数字可能在与较大数相加时被舍去。从大到小求和时，能在一定程度上减少这种因数量级差异导致的有效数字丢失，从而降低舍入误差累积 。


### 5.2 误差来源分析
1. 浮点数表示精度限制:计算机中浮点数采用有限位数表示，如单精度浮点数的精度约为7位十进制数，双精度约为15 - 16位十进制数。这就意味着对于超出其精度范围的数值，只能近似表示，必然存在误差 。
2. 加法运算中的舍入:在加法运算时，由于浮点数精度有限，当两个数相加结果超出可表示范围时，需要进行舍入操作。例如，将一个非常小的数与一个非常大的数相加，小的数可能在舍入过程中被忽略，导致结果不准确 。
3. 求和顺序的影响:不同的求和顺序会导致舍入误差累积情况不同。如前面所述，从小到大求和可能使舍入误差不断累积，而从大到小求和能相对减少误差累积 。


## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）
本实验发现求和顺序对计算精度有显著影响。从大到小求和（如S^{(down)} ）能在一定程度上减少舍入误差累积，相较于从小到大求和更为精确。此外，浮点数表示精度限制、加法运算中的舍入操作也都是数值计算中误差的重要来源。在进行数值求和计算时，需要充分考虑这些因素对结果精度的影响 。
## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？
从大到小求和时，较小的数在与较大数相加过程中，其对总和的影响相对较小，在浮点数精度限制下，因有效数字丢失导致的舍入误差累积相对较少。而从小到大求和，随着求和进行，舍入误差不断累积，最终结果偏离真实值更多 。
2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？
首先可尝试从大到小求和的策略，以减少舍入误差累积。还可以将相近数量级的数先进行求和，再将这些和进行汇总，避免因数量级差异过大导致有效数字丢失。另外，可采用更高精度的浮点数表示（如双精度甚至扩展精度类型）来降低误差 。

3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
使用多精度计算库，如GMP（GNU Multiple Precision Arithmetic Library），能提供比普通浮点数更高的精度；采用数值稳定的算法，例如在求解线性方程组时使用列主元高斯消去法替代普通高斯消去法可减少误差；对计算结果进行误差估计和校正，通过理论分析或蒙特卡罗模拟等方法估计误差范围，并对结果进行适当校正 。
## 附录：关键代码
```python
# 在此粘贴关键代码实现
def sum_up(N):
    """从小到大计算调和级数和"""
    result = 0.0
    for n in range(1, N + 1):
        result += 1.0 / n
    return result

def sum_down(N):
    """从大到小计算调和级数和"""
    result = 0.0
    for n in range(N, 0, -1):
        result += 1.0 / n
    return result

def calculate_relative_difference(N):
    """计算两种方法的相对差异"""
    s_up = sum_up(N)
    s_down = sum_down(N)
    return abs(s_up - s_down) / abs((s_up + s_down) / 2.0)
