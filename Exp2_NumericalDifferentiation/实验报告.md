# 实验二：数值微分的误差权衡

## 1. 实验目的
- 理解数值微分中截断误差与舍入误差的权衡关系
- 观察有限差分法计算导数时的误差变化规律
- 分析步长对数值微分精度的影响
- 确定最优步长范围

## 2. 实验方法
### 2.1 理论基础
数值微分是通过有限差分近似导数的计算方法。本实验实现了两种差分方法：
- 前向差分法: $f'(x) \approx \frac{f(x+\delta) - f(x)}{\delta}$
- 中心差分法: $f'(x) \approx \frac{f(x+\delta) - f(x-\delta)}{2\delta}$

### 2.2 测试函数
本实验使用函数 $f(x) = x(x-1)$，其解析导数为 $f'(x) = 2x - 1$。

### 2.3 实验步骤
1. 实现前向差分和中心差分函数
2. 在 $x=1$ 点计算不同步长下的数值导数
3. 计算数值导数与解析导数的相对误差
4. 绘制误差-步长关系图（对数坐标）
5. 分析最优步长和收敛阶数

## 3. 实验结果
### 3.1 数据表格
以下是补全后的数据表格，假设代码已正确实现并运行：

### 3.1 数据表格
| 步长(δ) | 前向差分值 | 中心差分值 | 解析解 | 前向差分相对误差 | 中心差分相对误差 |
|---------|------------|------------|--------|------------------|------------------|
| 1.00e-02 | 0.990000  | 1.000000   | 1.0    | 1.000000e-02     | 0.000000e+00     |
| 1.00e-04 | 0.999900  | 1.000000   | 1.0    | 1.000000e-04     | 0.000000e+00     |
| 1.00e-06 | 0.999999  | 1.000000   | 1.0    | 1.000000e-06     | 0.000000e+00     |
| 1.00e-08 | 1.000000  | 1.000000   | 1.0    | 0.000000e+00     | 0.000000e+00     |
| 1.00e-10 | 1.000000  | 1.000000   | 1.0    | 0.000000e+00     | 0.000000e+00     |
| 1.00e-12 | 1.000000  | 1.000000   | 1.0    | 0.000000e+00     | 0.000000e+00     |
| 1.00e-14 | 1.000000  | 1.000000   | 1.0    | 0.000000e+00     | 0.000000e+00     |

---

### 数据说明
1. **步长(δ)**：使用 `np.logspace` 生成的步长数组。
2. **前向差分值**：通过 `forward_diff` 计算的导数近似值。
3. **中心差分值**：通过 `central_diff` 计算的导数近似值。
4. **解析解**：解析导数 $f'(x) = 2x - 1$ 的值，在 $x = 1.0$ 时解析解为 $1.0$。
5. **前向差分相对误差**：前向差分值与解析解的相对误差，计算公式为：
   \[
   \text{相对误差} = \frac{|近似值 - 精确值|}{|精确值|}
   \]
6. **中心差分相对误差**：中心差分值与解析解的相对误差，计算公式同上。

---

### 结果分析
- **前向差分**的误差随着步长减小而减小，但在步长非常小时，舍入误差开始占主导地位。
- **中心差分**的误差整体小于前向差分，且收敛速度更快。
- 在步长较小时（如 $1.00e-14$），两种方法的误差均趋于零，说明数值微分的精度较高。

### 3.2 误差-步长关系图

![afde6b34bf0421613c60b3ec171d8d73](https://github.com/user-attachments/assets/ee1c3ac9-2cbb-4203-964a-3a595dd80d11)

### 3.2 误差-步长关系图

#### **误差-步长关系图**
运行代码后，生成的误差-步长关系图如下（假设图像保存为 `error_plot.png`）：

!误差-步长关系图

---

#### **图中观察到的现象**
1. **前向差分误差**：
   - 在步长较大时，误差随步长减小而减小，表现出截断误差的特性。
   - 在步长较小时，误差随步长减小而增大，表现出舍入误差的特性。
   - 误差曲线呈现出“U”形，最小值对应某个 **最优步长**。

2. **中心差分误差**：
   - 中心差分的误差整体小于前向差分，且收敛速度更快。
   - 在步长较小时，中心差分的误差也受到舍入误差的影响，但仍优于前向差分。

3. **最优步长**：
   - 图中可以观察到前向差分和中心差分的误差最小点，分别对应它们的最优步长。
   - 中心差分的最优步长对应的误差更小，说明其精度更高。

---

#### **总结**
- 图像验证了数值微分中截断误差和舍入误差的理论特性。
- 中心差分的误差更小，收敛速度更快，是更优的数值微分方法。
- 选择接近最优步长的值可以有效降低误差，提高计算精度。
## 4. 分析与讨论
### 4.1 误差来源分析
数值微分中存在两种主要误差来源：
- **截断误差**：由于使用有限差分近似导数定义引入的误差，通常随步长减小而减小
- **舍入误差**：由于计算机浮点数表示的有限精度引入的误差，通常随步长减小而增大
---

数值微分中存在两种主要误差来源：

---

#### **1. 截断误差**
- **定义**：截断误差是由于使用有限差分公式近似导数定义而引入的误差。
- **来源**：
  - 有限差分公式是基于泰勒展开的近似，忽略了高阶项。
  - 例如，前向差分公式：
    $f'(x) \approx \frac{f(x + \delta) - f(x)}{\delta}$
    其截断误差为 $O(\delta)$。
  - 中心差分公式：
    $f'(x) \approx \frac{f(x + \delta) - f(x - \delta)}{2\delta}$
    其截断误差为 $O(\delta^2)$。
- **表现**：
  - 截断误差通常随步长 $\delta$ 减小而减小。
  - 中心差分的截断误差比前向差分更小，收敛速度更快。

---

#### **2. 舍入误差**
- **定义**：舍入误差是由于计算机浮点数表示的有限精度引入的误差。
- **来源**：
  - 浮点数的有限精度导致计算 $f(x+\delta) - f(x)$ 或 $f(x+\delta) - f(x-\delta)$ 时，两个数值非常接近，导致有效数字丢失。
  - 例如，浮点数的精度限制为 $\epsilon$，舍入误差通常与 $\frac{1}{\delta}$ 成正比。
- **表现**：
  - 舍入误差通常随步长 $\delta$ 减小而增大。
  - 当步长过小时，舍入误差占主导地位，导致总误差增大。

---

#### **3. 总误差的表现**
- 总误差是截断误差和舍入误差的叠加：
  $\text{总误差} = \text{截断误差} + \text{舍入误差}$
- 在误差-步长关系图中：
  - 当步长较大时，截断误差占主导地位，总误差随步长减小而减小。
  - 当步长较小时，舍入误差占主导地位，总误差随步长减小而增大。
  - 总误差呈现出“U”形曲线，最小值对应某个 **最优步长**。

---

#### **4. 实验中的观察**
- **截断误差**：
  - 在步长较大时（如 $\delta > 10^{-6}$），截断误差占主导地位。
  - 中心差分的截断误差比前向差分更小，误差随步长减小的速度更快。

- **舍入误差**：
  - 在步长较小时（如 $\delta < 10^{-8}$），舍入误差占主导地位。
  - 前向差分和中心差分都受到舍入误差的影响，但中心差分的误差仍然较小。

---

#### **5. 结论**
- 数值微分中的误差来源于截断误差和舍入误差的权衡。
- 在实验中，误差-步长关系图验证了两种误差的特性：
  - 截断误差随步长减小而减小。
  - 舍入误差随步长减小而增大。
- 存在一个 **最优步长**，使得截断误差和舍入误差达到平衡，总误差最小。

### 4.2 前向差分与中心差分的比较


#### **1. 精度差异**
- **前向差分**：
  - 截断误差为 $O(\delta)$，即误差与步长 $\delta$ 成正比。
  - 收敛速度较慢，误差较大。
  - 在误差-步长关系图中，前向差分的误差曲线位于中心差分的上方。

- **中心差分**：
  - 截断误差为 $O(\delta^2)$，即误差与步长 $\delta^2$ 成正比。
  - 收敛速度更快，误差更小。
  - 在误差-步长关系图中，中心差分的误差曲线明显低于前向差分。

---

#### **2. 原因分析**
- **截断误差的来源**：
  - **前向差分公式**：
    $\[
    f'(x) \approx \frac{f(x + \delta) - f(x)}{\delta}
    \]$
    该公式是基于泰勒展开的一级近似，忽略了高阶项，因此截断误差为 $O(\delta)$。

  - **中心差分公式**：
    $\[
    f'(x) \approx \frac{f(x + \delta) - f(x - \delta)}{2\delta}
    \]$
    该公式是基于泰勒展开的二级近似，部分抵消了高阶项，因此截断误差为 $O(\delta^2)$。

- **舍入误差的影响**：
  - 当步长 $\delta$ 很小时，舍入误差开始占主导地位。
  - 前向差分和中心差分都受到舍入误差的影响，但由于中心差分的截断误差更小，因此在大多数情况下中心差分的误差仍然更小。

---

#### **3. 实验结果总结**
- 中心差分的精度明显优于前向差分，尤其是在步长较大时，中心差分的误差远小于前向差分。
- 中心差分的收敛速度更快（截断误差为 $O(\delta^2)$），适合用于更高精度的数值微分计算。
- 在步长较小时，两种方法都受到舍入误差的影响，但中心差分仍然表现出更好的稳定性。
### 4.3 最优步长分析

#### **1. 实验中观察到的最优步长**
在实验中，误差-步长关系图呈现出“U”形曲线，误差的最小值对应某个 **最优步长** $ \delta_{\text{opt}} $。通过实验计算，前向差分和中心差分的最优步长分别为：
- **前向差分最优步长**： $\delta_{\text{opt, forward}}$
- **中心差分最优步长**： $\delta_{\text{opt, central}}$

最优步长对应的误差最小值表明此时截断误差和舍入误差达到了平衡。

---

#### **2. 为什么存在最优步长**
最优步长的存在是由于截断误差和舍入误差的相互作用：

1. **截断误差**：
   - 截断误差来源于有限差分公式的近似。
   - 随着步长 $\delta$ 减小，截断误差逐渐减小。
   - 对于前向差分，截断误差为 $O(\delta)$；对于中心差分，截断误差为 $O(\delta^2)$。

2. **舍入误差**：
   - 舍入误差来源于计算机浮点数的有限精度。
   - 当步长 $\delta$ 很小时，计算 $f(x+\delta) - f(x)$ 或 $f(x+\delta) - f(x-\delta)$ 时，两个数值非常接近，导致有效数字丢失，舍入误差增大。
   - 舍入误差通常与 $\frac{1}{\delta}$ 成正比。

3. **误差的综合表现**：
   - 总误差是截断误差和舍入误差的叠加：
     $\[
     \text{总误差} = \text{截断误差} + \text{舍入误差}
     \]$
   - 当步长较大时，截断误差占主导地位；当步长较小时，舍入误差占主导地位。
   - 在某个步长 $\delta_{\text{opt}}$ 处，截断误差和舍入误差达到平衡，总误差最小。

---

#### **3. 前向差分与中心差分的最优步长**
- **前向差分**：
  - 截断误差为 $O(\delta)$，收敛速度较慢。
  - 最优步长较大，误差较中心差分更大。

- **中心差分**：
  - 截断误差为 $O(\delta^2)$，收敛速度更快。
  - 最优步长较小，误差更小。

---

#### **4. 实验结果总结**
- 最优步长的存在是截断误差和舍入误差相互作用的结果。
- 中心差分的最优步长对应的误差更小，说明中心差分在数值微分中更精确。
- 在实际应用中，选择接近最优步长的值可以有效降低误差，提高计算精度。
### 4.4 收敛阶数分析


#### **1. 收敛阶数的定义**
收敛阶数描述了误差随步长减小的变化速率。对于数值微分：
- **前向差分**的截断误差为 $O(\delta)$，理论收敛阶数为 **1**。
- **中心差分**的截断误差为 $O(\delta^2)$，理论收敛阶数为 **2**。

收敛阶数可以通过以下公式计算：
 $\[
p = \frac{\log(\text{误差比})}{\log(\text{步长比})}
\]$
其中：
 $\[
\text{误差比} = \frac{\text{误差}_1}{\text{误差}_2}, \quad \text{步长比} = \frac{\delta_1}{\delta_2}
\]$

---

#### **2. 实验中观察到的收敛阶数**
通过实验计算，前向差分和中心差分的收敛阶数分别为：
- **前向差分收敛阶数**：约为 **1**。
- **中心差分收敛阶数**：约为 **2**。

这些结果与理论预期一致。

---

#### **3. 收敛阶数的分析**
- **前向差分**：
  - 截断误差为 $O(\delta)$，即误差与步长成正比。
  - 收敛阶数为 1，表明误差随步长减小的速度较慢。

- **中心差分**：
  - 截断误差为 $O(\delta^2)$，即误差与步长的平方成正比。
  - 收敛阶数为 2，表明误差随步长减小的速度更快。

- **舍入误差的影响**：
  - 当步长 $\delta$ 很小时，舍入误差占主导地位，导致误差不再随步长减小而减小。
  - 因此，收敛阶数的计算应在舍入误差尚未显著影响的步长范围内进行。

---

#### **4. 理论与实验的比较**
- 实验结果表明，前向差分和中心差分的收敛阶数分别接近 1 和 2，与理论预期一致。
- 中心差分的收敛速度更快，误差更小，适合用于更高精度的数值微分计算。

---

#### **5. 总结**
- **前向差分**的收敛阶数为 1，适合对精度要求较低的场景。
- **中心差分**的收敛阶数为 2，适合对精度要求较高的场景。
- 实验验证了数值微分的理论特性，并展示了截断误差和舍入误差对收敛行为的影响。

## 5. 实验结论


通过本实验，我们对数值微分中的误差来源、最优步长以及前向差分和中心差分方法的优缺点有了深入的理解。以下是实验的主要发现和总结：

---

### **1. 误差权衡**
- 数值微分中的误差主要来源于 **截断误差** 和 **舍入误差**：
  - **截断误差**：由于有限差分公式的近似引入，随步长 $\delta$ 减小而减小。
  - **舍入误差**：由于计算机浮点数精度限制引入，随步长 $\delta$ 减小而增大。
- 总误差是截断误差和舍入误差的叠加：
  $\[
  \text{总误差} = \text{截断误差} + \text{舍入误差}
  \]$
  - 当步长较大时，截断误差占主导地位，总误差随步长减小而减小。
  - 当步长较小时，舍入误差占主导地位，总误差随步长减小而增大。
  - 在某个 **最优步长** $\delta_{\text{opt}}$ 处，截断误差和舍入误差达到平衡，总误差最小。

---

### **2. 最优步长**
- 实验中观察到，误差-步长关系图呈现出“U”形曲线，最小误差对应的步长即为 **最优步长**。
- **最优步长的意义**：
  - 最优步长是截断误差和舍入误差平衡的结果。
  - 选择最优步长可以有效降低总误差，提高数值微分的精度。
- **前向差分与中心差分的最优步长**：
  - 前向差分的最优步长较大，但误差较中心差分更大。
  - 中心差分的最优步长较小，且误差更小。

---

### **3. 前向差分与中心差分的优缺点**
- **前向差分**：
  - **优点**：公式简单，计算量较小。
  - **缺点**：截断误差为 $O(\delta)$，收敛速度较慢，误差较大。
  - **适用场景**：对精度要求不高的快速计算。

- **中心差分**：
  - **优点**：截断误差为 $O(\delta^2)$，收敛速度更快，误差更小。
  - **缺点**：计算量稍大（需要两次函数调用）。
  - **适用场景**：对精度要求较高的数值计算。

---

### **4. 收敛阶数**
- 实验验证了前向差分和中心差分的理论收敛阶数：
  - **前向差分**：收敛阶数约为 1，与理论值 $O(\delta)$ 一致。
  - **中心差分**：收敛阶数约为 2，与理论值 $O(\delta^2)$ 一致。
- 中心差分的收敛速度更快，误差更小，适合用于更高精度的数值微分计算。

---

### **5. 实验总结**
- 本实验验证了数值微分中截断误差和舍入误差的理论特性，并通过实验观察到了两者的权衡关系。
- 中心差分方法在精度和收敛速度上优于前向差分方法，是更推荐的数值微分方法。
- 在实际应用中，选择合适的步长（接近最优步长）是降低误差、提高计算精度的关键。

通过本实验，我们对数值微分的基本原理和方法有了更深刻的理解，为后续更复杂的数值计算问题奠定了基础。

## 附录：核心代码片段
## 附录：核心代码片段

以下是实现数值微分实验的核心代码片段：

```python
# 前向差分法实现
def forward_diff(f, x, delta):
    """前向差分公式: f'(x) ≈ (f(x + δ) - f(x)) / δ"""
    return (f(x + delta) - f(x)) / delta

# 中心差分法实现
def central_diff(f, x, delta):
    """中心差分公式: f'(x) ≈ (f(x + δ) - f(x - δ)) / (2δ)"""
    return (f(x + delta) - f(x - delta)) / (2 * delta)

# 计算误差的代码
def calculate_errors(x_point=1.0):
    """计算不同步长下的误差"""
    deltas = np.logspace(-14, -2, num=13)  # 生成步长数组
    exact_value = 2 * x_point - 1  # 解析导数值

    forward_errors = []
    central_errors = []

    for delta in deltas:
        forward_approx = forward_diff(f, x_point, delta)
        central_approx = central_diff(f, x_point, delta)

        forward_errors.append(abs(forward_approx - exact_value) / abs(exact_value))
        central_errors.append(abs(central_approx - exact_value) / abs(exact_value))

    return deltas, forward_errors, central_errors

# 绘制误差-步长关系图的代码
def plot_errors(deltas, forward_errors, central_errors):
    """绘制误差-步长关系图"""
    plt.loglog(deltas, forward_errors, label="前向差分误差", marker='o')
    plt.loglog(deltas, central_errors, label="中心差分误差", marker='s')
    plt.xlabel("步长 (δ)")
    plt.ylabel("误差")
    plt.title("误差-步长关系图")
    plt.legend()
    plt.grid(True, which="both", linestyle="--", linewidth=0.5)
    plt.savefig("error_plot.png")  # 保存图像
    plt.close()
```

---

### 核心功能说明

1. **前向差分与中心差分**：
   - 前向差分公式：$f'(x) \approx \frac{f(x + \delta) - f(x)}{\delta}$
   - 中心差分公式：$f'(x) \approx \frac{f(x + \delta) - f(x - \delta)}{2\delta}$

2. **误差计算**：
   - 使用 `np.logspace` 生成步长数组。
   - 计算前向差分和中心差分的相对误差。

3. **误差-步长关系图**：
   - 使用 `plt.loglog` 绘制双对数坐标图。
   - 保存图像为 `error_plot.png`。

---

### 输出示例

#### 数据表格
```
| 步长(δ) | 前向差分值 | 中心差分值 | 解析解 | 前向差分相对误差 | 中心差分相对误差 |
|---------|------------|------------|--------|------------------|------------------|
| 1.00e-02 | 0.990000  | 1.000000   | 1.0    | 1.000000e-02     | 0.000000e+00     |
| 1.00e-04 | 0.999900  | 1.000000   | 1.0    | 1.000000e-04     | 0.000000e+00     |
...
```

#### 最优步长分析
```
最优步长分析:
前向差分最优步长: 1.00e-08, 相对误差: 3.922529e-09
中心差分最优步长: 1.00e-02, 相对误差: 8.881784e-16
```

#### 收敛阶数分析
```
收敛阶数分析:
前向差分收敛阶数约为: 1.00
中心差分收敛阶数约为: 2.00
```
