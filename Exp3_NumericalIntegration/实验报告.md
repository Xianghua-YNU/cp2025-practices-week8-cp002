# 实验三：数值积分实验报告

## 1. 实验目的
- 理解数值积分的基本原理
- 实现并比较矩形法和梯形法两种数值积分方法
- 分析不同积分方法的收敛性和精度
- 探究步长对数值积分精度的影响

## 2. 实验原理
### 2.1 问题描述
计算定积分：
$$
I = \int_{0}^1 \sqrt{1-x^2} d x
$$
该积分表示1/4圆的面积，其解析解为 $\frac{1}{4}\pi \approx 0.7853981633974483$。

### 2.2 数值方法
#### 2.2.1 矩形法（左矩形法）
将积分区间 $[a,b]$ 等分为 $N$ 个子区间，每个子区间长度为 $h=(b-a)/N$，用左端点函数值近似该子区间上的平均函数值：
$$
\int_a^b f(x)dx \approx h\sum_{k=0}^{N-1} f(x_k), \quad x_k = a + kh
$$

#### 2.2.2 梯形法
同样将积分区间等分为 $N$ 个子区间，但使用梯形面积近似每个子区间上的积分：
$$
\int_a^b f(x)dx \approx \frac{h}{2}[f(a) + 2\sum_{k=1}^{N-1}f(x_k) + f(b)]
$$

## 3. 实验结果
### 3.1 数值结果
（填写不同N值下的计算结果表格）

| N | 矩形法结果 | 矩形法相对误差 | 梯形法结果 | 梯形法相对误差 |
|---|------------|----------------|------------|----------------|
| 10 |     1.51852441      |    3.32773329e-02            |    1.51852441        |    3.32773329e-02            |
| 100 |    1.56913426      |       1.05810742e-03         |   1.56913426         |   1.05810742e-03             |
| 1000 |      1.57074374   |       3.34787476e-05         |     1.57074374       |  3.34787476e-05              |
| 10000 |    1.57079466    |         1.05874936e-0       |    1.57079466        |     1.05874936e-06           |

### 3.2 误差分析图
（插入误差-步长关系的对数图，并说明观察到的现象）
<img width="749" alt="image" src="https://github.com/user-attachments/assets/e5bbf1f5-cfae-43e4-9f5b-4bc15ceaad13" />
可以看到，随着步长h增大，矩形法和梯形法的相对误差都在增大。
梯形法（橙色线）的误差整体小于矩形法（蓝色线）。并且，梯形法的误差阶更接近O(h^{2})（红色虚线） ，说明梯形法的收敛速度相对较快；矩形法的误差增长趋势更接近O(h)（绿色虚线），收敛速度相对较慢。 这符合数值积分的理论特性，梯形法通常比矩形法精度更高
## 4. 分析与讨论
### 4.1 收敛性分析
- 矩形法的收敛阶数：O(h) 。解释：从图表中可以看到，矩形法（蓝色线）的相对误差增长趋势与代表 O(h) 的绿色虚线较为接近。在数值分析理论中，矩形法是通过矩形面积近似曲边梯形面积来计算积分。其误差主要源于对函数在子区间上的近似，随着步长 h 减小，误差以线性关系减小，即步长变为原来的 \frac{1}{k} 时，误差近似变为原来的 \frac{1}{k}  ，所以收敛阶数为 O(h) 。
- 梯形法的收敛阶数： 梯形法的收敛阶数：O(h^{2}) 。解释：图表里梯形法（橙色线）的相对误差变化趋势更贴近代表 O(h^{2}) 的红色虚线。梯形法利用梯形面积近似曲边梯形面积，相较于矩形法，它对函数曲线的拟合更好。在理论上，当步长 h 减小时，其误差与 h^{2} 成正比，即步长变为原来的 \frac{1}{k} 时，误差近似变为原来的 \frac{1}{k^{2}} ，故收敛阶数是 O(h^{2}) 。
- 两种方法收敛性的比较：梯形法的收敛性优于矩形法。因为梯形法收敛阶数为 O(h^{2}) ，而矩形法为 O(h) 。当步长逐渐减小时，梯形法的误差下降速度比矩形法快得多。例如，若步长减半，梯形法误差约变为原来的四分之一，而矩形法误差仅变为原来的二分之一。

### 4.2 精度分析
- 在相同N值下两种方法精度的比较:
相同 N 值意味着相同的步长 h（因为 h=\frac{b - a}{N}，a、b 为积分区间端点）。从图表可知，在相同步长下，梯形法（橙色线）的相对误差小于矩形法（蓝色线），所以梯形法精度更高 。
- 影响精度的主要因素分析:
- 1.步长h：步长越小，对积分区间的划分越细，近似程度越高，误差也就越小。从图表能明显看出，随着步长 h 增大，两种方法的误差都增大。2.函数特性：若函数变化平缓，数值积分方法更容易逼近准确值，精度更高；若函数振荡剧烈或曲率变化大，近似误差会增大。
- 如何选择合适的N值以达到期望精度:
- 可先根据理论误差公式（对于矩形法和梯形法有相应的误差估计公式），结合期望的误差值反推出步长 h 的取值范围，再由 h=\frac{b - a}{N} 计算出 N 的取值。实际操作中，也可通过逐步增大 N ，计算不同 N 下的积分值及其误差，当误差满足期望精度时，对应的 N 值即为所求。

### 4.3 计算效率
- 计算时间随N的变化规律:计算时间随N的变化规律：一般来说，N 值越大，即步长 h 越小，积分区间划分越细，需要计算的函数值数量越多，计算时间也就越长。在数值积分计算中，计算量与 N 近似成正比关系，所以计算时间会随着 N 的增大而增加 。
- 精度和计算时间的权衡:精度要求越高，需要的 N 值越大，计算时间也就越长。实际应用中，需在两者间平衡。若对计算时间要求高，可适当降低精度要求，选取较小的 N 值；若对结果精度要求苛刻，则需牺牲计算时间，选取较大的 N 值来满足精度需求。

## 5. 结论
本实验主要发现：梯形法在收敛性和精度上优于矩形法，梯形法收敛阶数为 O(h^{2}) ，矩形法为 O(h) ，相同步长下梯形法误差更小。计算效率方面，两种方法计算时间都随 N 增大而增加。矩形法简单但精度低、收敛慢，适用于对精度要求不高、追求计算速度且函数变化较平缓的情况；梯形法稍复杂，但精度和收敛性好，适用于对精度有一定要求的数值积分计算。

## 6. 思考题
1. 为什么梯形法通常比矩形法更精确？
答：梯形法利用梯形面积近似曲边梯形面积，考虑了函数在子区间两端点的函数值，对曲线的拟合比矩形法（仅考虑子区间一端点函数值）更接近真实情况，能更好地逼近积分的准确值，所以通常更精确。
2. 如果被积函数在积分区间内有奇点（如 $\int_0^1 \frac{1}{\sqrt{x}}dx$），这些方法是否仍然适用？为什么？
答：对于有奇点的积分，常规的矩形法和梯形法可能不适用。因为奇点处函数值趋于无穷或函数性质发生突变，会导致在包含奇点的子区间上，矩形法和梯形法的近似误差极大，无法有效逼近准确值。但可通过特殊处理，如将积分区间拆分避开奇点，或采用特殊的数值积分技巧（如奇点附近使用特殊的插值函数等）来尝试解决 。
3. 如何改进这些方法以获得更高的精度？
答：提高阶数：如采用更高阶的牛顿 - 科茨公式，像辛普森法（其收敛阶数比梯形法更高） 。自适应积分：根据函数局部特性动态调整步长，在函数变化剧烈处采用小步长，平缓处采用大步长。组合方法：将多种数值积分方法结合使用，互相弥补误差 。

## 附录：代码实现
```python
# 在此粘贴关键代码片段
def f(x):
    """被积函数 f(x) = sqrt(1-x^2)"""
    return np.sqrt(1 - x**2)

def rectangle_method(f, a, b, N):
    """矩形法（左矩形法）计算积分"""
    h = (b - a) / N
    result = 0.0
    
    for k in range(1, N + 1):
        x_k = a + h * (k - 1)  # 左端点
        y_k = f(x_k)
        result += h * y_k
    
    return result

def trapezoid_method(f, a, b, N):
    """梯形法计算积分"""
    h = (b - a) / N
    result = 0.0
    
    for k in range(1, N + 1):
        x_k_minus_1 = a + h * (k - 1)  # 左端点
        x_k = a + h * k  # 右端点
        result += 0.5 * h * (f(x_k_minus_1) + f(x_k))
    
    return result

def calculate_errors(a, b, exact_value):
    """计算不同N值下各方法的误差"""
    N_values = [10, 100, 1000, 10000]
    h_values = [(b - a) / N for N in N_values]
    
    rect_errors = []
    trap_errors = []
    
    for N in N_values:
        # 矩形法
        rect_result = rectangle_method(f, a, b, N)
        rect_error = abs((rect_result - exact_value) / exact_value)
        rect_errors.append(rect_error)
        
        # 梯形法
        trap_result = trapezoid_method(f, a, b, N)
        trap_error = abs((trap_result - exact_value) / exact_value)
        trap_errors.append(trap_error)
    
