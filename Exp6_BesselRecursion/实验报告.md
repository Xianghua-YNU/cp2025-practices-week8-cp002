# 实验六：球贝塞尔函数的递推关系与数值稳定性实验报告

## 1. 实验目的
1. 实现并比较球贝塞尔函数的向上和向下递推计算方法
2. 理解并掌握向下递推结果的归一化方法
3. 通过实验观察和分析不同递推方法的数值稳定性
4. 深入理解数值计算中的误差放大和抑制机制

## 2. 实验原理
### 2.1 球贝塞尔函数
球贝塞尔函数 $j_l(x)$ 满足二阶线性常微分方程：
$$ x^2 f''(x) + 2xf'(x) + [x^2 - l(l+1)]f(x) = 0 $$

最低阶的两个函数解析形式：
$$ j_0(x) = \frac{\sin x}{x} $$
$$ j_1(x) = \frac{\sin x}{x^2} - \frac{\cos x}{x} $$

### 2.2 递推关系
1. 向上递推：
   $$ j_{l+1}(x) = \frac{2l+1}{x} j_l(x) - j_{l-1}(x) $$

2. 向下递推：
   $$ j_{l-1}(x) = \frac{2l+1}{x} j_l(x) - j_{l+1}(x) $$

### 2.3 归一化方法
向下递推结果的归一化：
$$ j_l^\mathrm{normalized}(x) = j_l^\mathrm{compute}(x) \times \frac{j_0^\mathrm{analytic}(x)}{j_0^\mathrm{compute}(x)} $$

## 3. 实验方法
### 3.1 代码实现
1. `bessel_up(x, lmax)` 函数实现：
   - bessel_up(x, lmax) 使用向上递推法（Forward Recurrence）计算球贝塞尔函数l=0到l=lmax的值。

   - ![image](https://github.com/user-attachments/assets/faa11b41-05e7-414d-b9d7-63b6fa23dfcb)
![image](https://github.com/user-attachments/assets/1e0781c7-c8ae-423c-a374-03eb99f0a38b)

   - 初始化数组 j = np.zeros(lmax + 1)  # 存储 j_0 到 j_lmax
   填充初始值
   向上递推（l=1到l=lmax−1）：
   for l in range(1, lmax):
    j[l+1] = (2*l + 1) / x * j[l] - j[l-1]

3. `bessel_down(x, lmax, m_start)` 函数实现：
   - bessel_down(x, lmax, m_start) 使用向下递推法（Backward Recurrence）计算球贝塞尔函数从l=0到l=lmax的值。
      递推关系基于球贝塞尔函数的反向递推公式：
     ![image](https://github.com/user-attachments/assets/839b81e6-afb9-4bf7-b662-1efa12a8fde0)

   - 默认从mstart=lmax+15开始递推（经验值，确保低阶结果稳定）。

   - 初始化临时数组：j_temp = np.zeros(m_start + 2)  # 存储 j_0 到 j_{m_start+1}
      向下递推:for l in range(m_start, 0, -1):
    j_temp[l-1] = (2*l + 1) / x * j_temp[l] - j_temp[l+1]
     
   - 归一化因子：
     j0_analytic = np.sin(x) / x if x != 0 else 1.0
      scale = j0_analytic / j_temp[0]  # 计算缩放因子
      归一化结果：j = j_temp[:lmax + 1] * scale  # 截取所需阶数并缩放

### 3.2 数据收集与处理
1. 测试点选取：x = 0.1, 1.0, 10.0
2. 计算范围：l = 0 到 25
3. 与scipy.special.spherical_jn比较
4. 误差计算方法

## 4. 实验结果
### 4.1 数值结果
| x | l | $j_l^\mathrm{up}(x)$ | $j_l^\mathrm{down}(x)$ | $j_l^\mathrm{scipy}(x)$ |
|---|---|----------------------|------------------------|-------------------------|
| 0.1 | 3 |                      |                        |                         |
| 0.1 | 5 |                      |                        |                         |
| 0.1 | 8 |                      |                        |                         |
| 1.0 | 3 |                      |                        |                         |
| ... | ... |                    |                        |                         |

x = 0.1:
l	Up		Down		Scipy
--------------------------------------------------
3	9.518517e-06	9.518520e-06	9.518520e-06
5	-1.445698e-08	9.616310e-10	9.616310e-10
8	-3.306558e-02	2.901200e-16	2.901200e-16

x = 1.0:
l	Up		Down		Scipy
--------------------------------------------------
3	9.006581e-03	9.006581e-03	9.006581e-03
5	9.256116e-05	9.256116e-05	9.256116e-05
8	2.817901e-08	2.826499e-08	2.826499e-08

x = 10.0:
l	Up		Down		Scipy
--------------------------------------------------
3	-3.949584e-02	-3.949585e-02	-3.949584e-02
5	-5.553451e-02	-5.553451e-02	-5.553451e-02
8	1.255780e-01	1.255780e-01	1.255780e-01

### 4.2 误差分析图
（在此插入三个x值对应的半对数图）
![c9d0fdbf565444773224023aa77fcfd1](https://github.com/user-attachments/assets/797579fa-690f-484f-ab34-d9a6a26d96ea)
![949c6ec678dc37b0356d9ba0f667b730](https://github.com/user-attachments/assets/c9ba2943-496b-4117-b829-3d100b424cda)
![d4fe4de26d101182900f49f6c4d22906](https://github.com/user-attachments/assets/710f9503-ed08-41ce-9cf4-8610363b4528)



## 5. 分析与讨论
### 5.1 数值稳定性分析
1. 向上递推的不稳定性：
   - 失效区域分析（l>x时的表现）
     向上递推法在计算球贝塞尔函数时，当阶数l>x，计算结果会迅速失去精度，甚至完全失效。具体表现如下：
      l≈x 时：
      计算结果开始出现显著误差，相对误差可能达到10^−2量级。
      l>x 时：
      误差呈指数级增长，计算结果可能溢出（如输出 inf 或完全错误的值）。

      典型失效场景：
      x=1.0，l≥5时误差显著。
      x=10.0,l≥15时误差急剧增大。

   - 误差放大机制分析
     递推公式的敏感性:
      
     误差以指数形式累积，类似正向迭代一个不稳定的差分方程。
     数值类比：


   - 与球诺伊曼函数的关系


1. 向下递推的稳定性：
   - 误差抑制机制
   - 归一化的作用
   - 计算精度分析

### 5.2 计算效率比较
1. 两种方法的计算时间对比
2. 影响计算效率的因素分析

## 6. 结论
1. 两种递推方法的适用条件
2. 数值稳定性的重要性
3. 归一化在提高计算精度中的作用

## 7. 思考题
1. 为什么向上递推在l > x时会变得不稳定？

2. 向下递推为什么能够有效抑制误差？

3. 如何选择合适的m_start值以保证计算精度？

## 附录：关键代码
```python
# 在此粘贴关键代码实现
