# 实验六：球贝塞尔函数的递推关系与数值稳定性实验报告

## 1. 实验目的
1. 实现并比较球贝塞尔函数的向上和向下递推计算方法
2. 理解并掌握向下递推结果的归一化方法
3. 通过实验观察和分析不同递推方法的数值稳定性
4. 深入理解数值计算中的误差放大和抑制机制

## 2. 实验原理
### 2.1 球贝塞尔函数
球贝塞尔函数 $j_l(x)$ 满足二阶线性常微分方程：
$$ x^2 f''(x) + 2xf'(x) + [x^2 - l(l+1)]f(x) = 0 $$

最低阶的两个函数解析形式：
$$ j_0(x) = \frac{\sin x}{x} $$
$$ j_1(x) = \frac{\sin x}{x^2} - \frac{\cos x}{x} $$

### 2.2 递推关系
1. 向上递推：
   $$ j_{l+1}(x) = \frac{2l+1}{x} j_l(x) - j_{l-1}(x) $$

2. 向下递推：
   $$ j_{l-1}(x) = \frac{2l+1}{x} j_l(x) - j_{l+1}(x) $$

### 2.3 归一化方法
向下递推结果的归一化：
$$ j_l^\mathrm{normalized}(x) = j_l^\mathrm{compute}(x) \times \frac{j_0^\mathrm{analytic}(x)}{j_0^\mathrm{compute}(x)} $$

## 3. 实验方法
### 3.1 代码实现
1. `bessel_up(x, lmax)` 函数实现：
   - bessel_up(x, lmax) 使用向上递推法（Forward Recurrence）计算球贝塞尔函数l=0到l=lmax的值。

   - ![image](https://github.com/user-attachments/assets/faa11b41-05e7-414d-b9d7-63b6fa23dfcb)
![image](https://github.com/user-attachments/assets/1e0781c7-c8ae-423c-a374-03eb99f0a38b)

   - 初始化数组 j = np.zeros(lmax + 1)  # 存储 j_0 到 j_lmax
   填充初始值
   向上递推（l=1到l=lmax−1）：
   for l in range(1, lmax):
    j[l+1] = (2*l + 1) / x * j[l] - j[l-1]

2. `bessel_down(x, lmax, m_start)` 函数实现：
   - bessel_down(x, lmax, m_start) 使用向下递推法（Backward Recurrence）计算球贝塞尔函数从l=0到l=lmax的值。
      递推关系基于球贝塞尔函数的反向递推公式：
     ![image](https://github.com/user-attachments/assets/839b81e6-afb9-4bf7-b662-1efa12a8fde0)

   - 默认从mstart=lmax+15开始递推（经验值，确保低阶结果稳定）。

   - 初始化临时数组：j_temp = np.zeros(m_start + 2)  # 存储 j_0 到 j_{m_start+1}
      向下递推:for l in range(m_start, 0, -1):
    j_temp[l-1] = (2*l + 1) / x * j_temp[l] - j_temp[l+1]
     
   - 归一化因子：
     j0_analytic = np.sin(x) / x if x != 0 else 1.0
      scale = j0_analytic / j_temp[0]  # 计算缩放因子
      归一化结果：j = j_temp[:lmax + 1] * scale  # 截取所需阶数并缩放

### 3.2 数据收集与处理
1. 测试点选取：x = 0.1, 1.0, 10.0
2. 计算范围：l = 0 到 25
3. 与scipy.special.spherical_jn比较
4. 误差计算方法

## 4. 实验结果
### 4.1 数值结果
l
Up
Down
Scipy
3
1.333333e-05
1.333333e-05
1.333333e-05
5
2.666667e-07
2.666667e-07
2.666667e-07
8
4.285714e-09
4.285714e-09
4.285714e-09

x = 0.1:
l	Up		Down		Scipy
--------------------------------------------------
3	9.518517e-06	9.518520e-06	9.518520e-06
5	-1.445698e-08	9.616310e-10	9.616310e-10
8	-3.306558e-02	2.901200e-16	2.901200e-16

x = 1.0:
l	Up		Down		Scipy
--------------------------------------------------
3	9.006581e-03	9.006581e-03	9.006581e-03
5	9.256116e-05	9.256116e-05	9.256116e-05
8	2.817901e-08	2.826499e-08	2.826499e-08

x = 10.0:
l	Up		Down		Scipy
--------------------------------------------------
3	-3.949584e-02	-3.949585e-02	-3.949584e-02
5	-5.553451e-02	-5.553451e-02	-5.553451e-02
8	1.255780e-01	1.255780e-01	1.255780e-01

### 4.2 误差分析图
（在此插入三个x值对应的半对数图）
![c9d0fdbf565444773224023aa77fcfd1](https://github.com/user-attachments/assets/797579fa-690f-484f-ab34-d9a6a26d96ea)
![949c6ec678dc37b0356d9ba0f667b730](https://github.com/user-attachments/assets/c9ba2943-496b-4117-b829-3d100b424cda)
![d4fe4de26d101182900f49f6c4d22906](https://github.com/user-attachments/assets/710f9503-ed08-41ce-9cf4-8610363b4528)



## 5. 分析与讨论
### 5.1 数值稳定性分析
1. 向上递推的不稳定性：
   - 失效区域分析（l>x时的表现）
     向上递推法在计算球贝塞尔函数时，当阶数l>x，计算结果会迅速失去精度，甚至完全失效。具体表现如下：
      l≈x 时：
      计算结果开始出现显著误差，相对误差可能达到10^−2量级。
      l>x 时：
      误差呈指数级增长，计算结果可能溢出（如输出 inf 或完全错误的值）。

      典型失效场景：
      x=1.0，l≥5时误差显著。
      x=10.0,l≥15时误差急剧增大。

   - 误差放大机制分析
     递推公式的敏感性:
      ![bbe617a901509ef1c6eb85a3499a77dc](https://github.com/user-attachments/assets/71046a87-0ee9-48b9-b218-0ba0ddbfdb1a)
     误差以指数形式累积，类似正向迭代一个不稳定的差分方程。
     数值类比：类似于用迭代法解微分方程时，步长过大导致解发散。

   - 与球诺伊曼函数的关系
   物理意义：jl(x) 代表物理可行的正则解（在原点有限）。yl(x) 是非物理解（在原点发散），递推误差将其激活。

2. 向下递推的稳定性：
   - 误差抑制机制
     ![image](https://github.com/user-attachments/assets/72e1f1c0-dbbb-4998-96b6-a20e8dfa3e07)
      球贝塞尔函数在高阶时自然衰减
     递推过程中，数值误差被 指数衰减抑制（与向上递推的指数放大相反）。
     
   - 归一化的作用
     向下递推需从任意高阶初始值（如jmstart=1）开始，计算结果仅为真实值的比例近似，必须通过归一化修正。
     
   - 计算精度分析
     机器精度（10^−12∼10^−15）

### 5.2 计算效率比较
1. 两种方法的计算时间对比
向上递推更快，但仅适用于稳定区域 (l≤x)。
向下递推稍慢，但稳定性全覆盖，适合通用计算。

2. 影响计算效率的因素分析
递推算法的选择、数值操作的代价、内存访问模式、函数调用与误差处理。

## 6. 结论
1. 两种递推方法的适用条件
向上递推法：
低阶计算：当目标阶数l远小于 x（即l≪x）时稳定性最佳。
小x场景。

向下递推法：
高阶计算：当l≥x或需要计算高阶（如l>20）时，数值稳定性显著优于向上递推。
大 l范围：即使 x较小，只要 l足够大（如l≫x），向下递推仍稳定。

2. 数值稳定性的重要性
数值失稳会导致误差指数级放大、有效数字完全丢失、溢出/下溢风险。

3. 归一化在提高计算精度中的作用
减少数值范围差异，避免溢出/下溢、抑制舍入误差、提高迭代算法的收敛性与稳定性、避免数值抵消、提升矩阵运算的条件数。


## 7. 思考题
1. 为什么向上递推在l > x时会变得不稳定？
递推关系的数学性质与数值误差的累积效应，尤其是在递推过程中涉及 大数相减或递推系数增长过快的情况。递推的不稳定性通常由以下因素导致：递推系数的放大效应、解的渐近行为主导、数值抵消。
2. 向下递推为什么能够有效抑制误差？
其数学上的自然衰减特性和误差传播的自我修正机制。压制递增解，保留递减解，向下递推的误差传播具有收缩性，避免大数运算，减少舍入误差和数值抵消。
3. 如何选择合适的m_start值以保证计算精度？
需要平衡计算效率和数值精度。
覆盖衰减区：mstart必须足够大，使得目标函数在≥mstart时已进入指数衰减区。
避免过度计算：mstart过大会增加不必要的计算量，甚至因浮点数精度限制引入噪声。
## 附录：关键代码
```python
# 在此粘贴关键代码实现
import numpy as np

def bessel_downward_recurrence(m_target, x, epsilon=1e-12):
    """
    通过向下递推计算贝塞尔函数 J_m(x) 的值
    
    参数:
        m_target (int): 目标阶数
        x (float): 自变量
        epsilon (float): 截断误差容限
    
    返回:
        J_m_target (float): J_{m_target}(x) 的值
    """
    # 1. 动态选择起始阶数 m_start
    m_start = max(m_target, int(x + 12 * np.sqrt(x)))  # 经验公式
    
    # 2. 初始化递推数组（从高阶向低阶计算）
    J = np.zeros(m_start + 2)  # 多留一位避免越界
    J[m_start + 1] = 0.0       # f_{m_start+1} = 0
    J[m_start] = 1.0e-20       # 任意小初始值（触发递减解）
    
    # 3. 向下递推（Miller算法）
    for m in range(m_start, 0, -1):
        J[m-1] = (2 * m / x) * J[m] - J[m+1]
    
    # 4. 归一化（利用已知条件 J_0(x) + 2ΣJ_{2m}(x) = 1）
    norm = J[0] + 2 * np.sum(J[2::2])  # 计算归一化因子
    J_normalized = J / norm
    
    # 5. 返回目标阶数的值
    return J_normalized[m_target]

# 示例：计算 J_10(5.0)
result = bessel_downward_recurrence(10, 5.0)
print(f"J_10(5.0) = {result:.12e}")
